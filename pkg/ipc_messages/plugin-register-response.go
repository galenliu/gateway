// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package messages

import "fmt"
import "encoding/json"

// Message-specific data
type PluginRegisterResponseJsonData struct {
	// Version of the running gateway
	GatewayVersion string `json:"gatewayVersion" yaml:"gatewayVersion"`

	// ID of the plugin which has been registered
	PluginId string `json:"pluginId" yaml:"pluginId"`

	// User preferences
	Preferences PluginRegisterResponseJsonDataPreferences `json:"preferences" yaml:"preferences"`

	// User profile information, e.g. file paths of various things
	UserProfile PluginRegisterResponseJsonDataUserProfile `json:"userProfile" yaml:"userProfile"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PluginRegisterResponseJsonDataPreferencesUnits) UnmarshalJSON(b []byte) error {
	var raw map[string]any
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["temperature"]; !ok || v == nil {
		return fmt.Errorf("field temperature in PluginRegisterResponseJsonDataPreferencesUnits: required")
	}
	type Plain PluginRegisterResponseJsonDataPreferencesUnits
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PluginRegisterResponseJsonDataPreferencesUnits(plain)
	return nil
}

// Acknowledgement that the gateway has registered a plugin
type PluginRegisterResponseJson struct {
	// Message-specific data
	Data PluginRegisterResponseJsonData `json:"data" yaml:"data"`

	// The message type, used by the IPC client and server to differentiate messages
	MessageType int `json:"messageType" yaml:"messageType"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PluginRegisterResponseJsonDataPreferences) UnmarshalJSON(b []byte) error {
	var raw map[string]any
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["language"]; !ok || v == nil {
		return fmt.Errorf("field language in PluginRegisterResponseJsonDataPreferences: required")
	}
	if v, ok := raw["units"]; !ok || v == nil {
		return fmt.Errorf("field units in PluginRegisterResponseJsonDataPreferences: required")
	}
	type Plain PluginRegisterResponseJsonDataPreferences
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PluginRegisterResponseJsonDataPreferences(plain)
	return nil
}

// User profile information, e.g. file paths of various things
type PluginRegisterResponseJsonDataUserProfile struct {
	// Add-ons directory, e.g. "/home/pi/.webthings/addons"
	AddonsDir string `json:"addonsDir" yaml:"addonsDir"`

	// Base user profile directory, e.g. "/home/pi/.webthings"
	BaseDir string `json:"baseDir" yaml:"baseDir"`

	// Configuration directory, e.g. "/home/pi/.webthings/config"
	ConfigDir string `json:"configDir" yaml:"configDir"`

	// Data directory, e.g. "/home/pi/.webthings/data"
	DataDir string `json:"dataDir" yaml:"dataDir"`

	// Gateway directory, e.g. "/home/pi/webthings/gateway"
	GatewayDir string `json:"gatewayDir" yaml:"gatewayDir"`

	// Log directory, e.g. "/home/pi/.webthings/log"
	LogDir string `json:"logDir" yaml:"logDir"`

	// Media directory, e.g. "/home/pi/.webthings/media"
	MediaDir string `json:"mediaDir" yaml:"mediaDir"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PluginRegisterResponseJsonDataUserProfile) UnmarshalJSON(b []byte) error {
	var raw map[string]any
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["addonsDir"]; !ok || v == nil {
		return fmt.Errorf("field addonsDir in PluginRegisterResponseJsonDataUserProfile: required")
	}
	if v, ok := raw["baseDir"]; !ok || v == nil {
		return fmt.Errorf("field baseDir in PluginRegisterResponseJsonDataUserProfile: required")
	}
	if v, ok := raw["configDir"]; !ok || v == nil {
		return fmt.Errorf("field configDir in PluginRegisterResponseJsonDataUserProfile: required")
	}
	if v, ok := raw["dataDir"]; !ok || v == nil {
		return fmt.Errorf("field dataDir in PluginRegisterResponseJsonDataUserProfile: required")
	}
	if v, ok := raw["gatewayDir"]; !ok || v == nil {
		return fmt.Errorf("field gatewayDir in PluginRegisterResponseJsonDataUserProfile: required")
	}
	if v, ok := raw["logDir"]; !ok || v == nil {
		return fmt.Errorf("field logDir in PluginRegisterResponseJsonDataUserProfile: required")
	}
	if v, ok := raw["mediaDir"]; !ok || v == nil {
		return fmt.Errorf("field mediaDir in PluginRegisterResponseJsonDataUserProfile: required")
	}
	type Plain PluginRegisterResponseJsonDataUserProfile
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PluginRegisterResponseJsonDataUserProfile(plain)
	return nil
}

// User's preferred units
type PluginRegisterResponseJsonDataPreferencesUnits struct {
	// Preferred temperature unit, e.g. "degree celsius"
	Temperature string `json:"temperature" yaml:"temperature"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PluginRegisterResponseJsonData) UnmarshalJSON(b []byte) error {
	var raw map[string]any
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["gatewayVersion"]; !ok || v == nil {
		return fmt.Errorf("field gatewayVersion in PluginRegisterResponseJsonData: required")
	}
	if v, ok := raw["pluginId"]; !ok || v == nil {
		return fmt.Errorf("field pluginId in PluginRegisterResponseJsonData: required")
	}
	if v, ok := raw["preferences"]; !ok || v == nil {
		return fmt.Errorf("field preferences in PluginRegisterResponseJsonData: required")
	}
	if v, ok := raw["userProfile"]; !ok || v == nil {
		return fmt.Errorf("field userProfile in PluginRegisterResponseJsonData: required")
	}
	type Plain PluginRegisterResponseJsonData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PluginRegisterResponseJsonData(plain)
	return nil
}

// User preferences
type PluginRegisterResponseJsonDataPreferences struct {
	// User's preferred language, e.g. "en-US"
	Language string `json:"language" yaml:"language"`

	// User's preferred units
	Units PluginRegisterResponseJsonDataPreferencesUnits `json:"units" yaml:"units"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PluginRegisterResponseJson) UnmarshalJSON(b []byte) error {
	var raw map[string]any
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["data"]; !ok || v == nil {
		return fmt.Errorf("field data in PluginRegisterResponseJson: required")
	}
	if v, ok := raw["messageType"]; !ok || v == nil {
		return fmt.Errorf("field messageType in PluginRegisterResponseJson: required")
	}
	type Plain PluginRegisterResponseJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PluginRegisterResponseJson(plain)
	return nil
}
